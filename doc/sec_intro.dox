/*!\page sec_intro Introduction

The basic datatype of the library is the class Tensor, which implements the
above mentioned multi-dimensional array. This class allows accessing the
array elements one by one, extracting pieces of an array, reshaping arrays, etc
\code
  Tensor<double> a = Tensor<double>::eye(2,2); // creates a 2x2 identity matrix
  double one = a(0,0);                         // returns the upper left element
  Tensor<double> b = a(range(0,-1), _);        // returns first to last row, all columns
  Tensor<double> c = reshape(b, 1,4);          // converts b into a row vector
  RTensor d = reshape(b, 1, 4);                // same as above, RTensor is an alias
\endcode


\section sec_intro_features Features

There are many philosophical constraints behind the library implementation
itself, motivated by the writer's need of a Matlab-like environment that
allows quick prototyping of code. Some of them are
\li Automatic memory management
\li Efficiency
\li Simple syntax
\li Safety

The memory management is done using a copy-on-write pointer mechanism, which allows
two arrays to share the same data until one of them modifies the shared memory.
\code
  Tensor<double> a = Tensor<double>::eye(2,2);
  Tensor<double> b = a;                        // a and b point to the same array
  a.at(0,1) = 1.0;                             // a points now to a different memory
\endcode
Since copying is cheap, it becomes feasible to have multiple references to the
same array in structures such as vectors, lists, etc. It also makes the actual
coding straightforward, since no bookkeeping has to be done

\section sec_intro_errors Error handling

The library adopts the C++ Core Guidelines, implementing various contracts
that verify user input and some of the generated data.

- In debug mode, the contracts are always enforced and, in case of error, the
  library signals an exception.

- In release mode or when TENSOR_DEBUG is OFF, some of those contracts are
  deactivated, and the remaining ones result in a call to `std::terminate`.

This choice is by design. In principle, when Tensor receives wrong inputs,
for instance wrong indices into tensors or wrong shapes for a tensor view,
this must be considered a logical error from which one may not recovered.
However, it is acknowledged that some projects may need from a kind of
error recovery, to close resources used during a project or to log the
error.

- In production coude, you may install your own `std::terminate_handler` to
  handle those error conditions.

- In debug mode or when testing, `std::terminate_handler` still works, unless
  you want to capture exceptions to detect and debug those conditions using
  `try/catch`.
*/
